# encoding: utf-8
# module scipy.sparse.csgraph._traversal
# from /.venv/lib/python3.8/site-packages/scipy/sparse/csgraph/_traversal.cpython-38-aarch64-linux-gnu.so
# by generator 1.147
""" Routines for traversing graphs in compressed sparse format """

# imports
import builtins as __builtins__ # <module 'builtins' (built-in)>
import numpy as np # /.venv/lib/python3.8/site-packages/numpy/__init__.py
from scipy.sparse.csgraph._tools import reconstruct_path

import numpy as __numpy


# functions

def breadth_first_order(csgraph, i_start, directed=True, return_predecessors=True): # real signature unknown; restored from __doc__
    """
    breadth_first_order(csgraph, i_start, directed=True, return_predecessors=True)
    
        Return a breadth-first ordering starting with specified node.
    
        Note that a breadth-first order is not unique, but the tree which it
        generates is unique.
    
        .. versionadded:: 0.11.0
    
        Parameters
        ----------
        csgraph : array_like or sparse matrix
            The N x N compressed sparse graph.  The input csgraph will be
            converted to csr format for the calculation.
        i_start : int
            The index of starting node.
        directed : bool, optional
            If True (default), then operate on a directed graph: only
            move from point i to point j along paths csgraph[i, j].
            If False, then find the shortest path on an undirected graph: the
            algorithm can progress from point i to j along csgraph[i, j] or
            csgraph[j, i].
        return_predecessors : bool, optional
            If True (default), then return the predecesor array (see below).
    
        Returns
        -------
        node_array : ndarray, one dimension
            The breadth-first list of nodes, starting with specified node.  The
            length of node_array is the number of nodes reachable from the
            specified node.
        predecessors : ndarray, one dimension
            Returned only if return_predecessors is True.
            The length-N list of predecessors of each node in a breadth-first
            tree.  If node i is in the tree, then its parent is given by
            predecessors[i]. If node i is not in the tree (and for the parent
            node) then predecessors[i] = -9999.
    
        Examples
        --------
        >>> from scipy.sparse import csr_matrix
        >>> from scipy.sparse.csgraph import breadth_first_order
    
        >>> graph = [
        ... [0, 1, 2, 0],
        ... [0, 0, 0, 1],
        ... [2, 0, 0, 3],
        ... [0, 0, 0, 0]
        ... ]
        >>> graph = csr_matrix(graph)
        >>> print(graph)
          (0, 1)    1
          (0, 2)    2
          (1, 3)    1
          (2, 0)    2
          (2, 3)    3
    
        >>> breadth_first_order(graph,0)
        (array([0, 1, 2, 3], dtype=int32), array([-9999,     0,     0,     1], dtype=int32))
    """
    pass

def breadth_first_tree(csgraph, i_start, directed=True): # real signature unknown; restored from __doc__
    """
    breadth_first_tree(csgraph, i_start, directed=True)
    
        Return the tree generated by a breadth-first search
    
        Note that a breadth-first tree from a specified node is unique.
    
        .. versionadded:: 0.11.0
    
        Parameters
        ----------
        csgraph : array_like or sparse matrix
            The N x N matrix representing the compressed sparse graph.  The input
            csgraph will be converted to csr format for the calculation.
        i_start : int
            The index of starting node.
        directed : bool, optional
            If True (default), then operate on a directed graph: only
            move from point i to point j along paths csgraph[i, j].
            If False, then find the shortest path on an undirected graph: the
            algorithm can progress from point i to j along csgraph[i, j] or
            csgraph[j, i].
    
        Returns
        -------
        cstree : csr matrix
            The N x N directed compressed-sparse representation of the breadth-
            first tree drawn from csgraph, starting at the specified node.
    
        Examples
        --------
        The following example shows the computation of a depth-first tree
        over a simple four-component graph, starting at node 0::
    
             input graph          breadth first tree from (0)
    
                 (0)                         (0)
                /   \                       /   \
               3     8                     3     8
              /       \                   /       \
            (3)---5---(1)               (3)       (1)
              \       /                           /
               6     2                           2
                \   /                           /
                 (2)                         (2)
    
        In compressed sparse representation, the solution looks like this:
    
        >>> from scipy.sparse import csr_matrix
        >>> from scipy.sparse.csgraph import breadth_first_tree
        >>> X = csr_matrix([[0, 8, 0, 3],
        ...                 [0, 0, 2, 5],
        ...                 [0, 0, 0, 6],
        ...                 [0, 0, 0, 0]])
        >>> Tcsr = breadth_first_tree(X, 0, directed=False)
        >>> Tcsr.toarray().astype(int)
        array([[0, 8, 0, 3],
               [0, 0, 2, 0],
               [0, 0, 0, 0],
               [0, 0, 0, 0]])
    
        Note that the resulting graph is a Directed Acyclic Graph which spans
        the graph.  A breadth-first tree from a given node is unique.
    """
    pass

def connected_components(csgraph, directed=True, connection='weak', return_labels=True): # real signature unknown; restored from __doc__
    """
    connected_components(csgraph, directed=True, connection='weak',
                             return_labels=True)
    
        Analyze the connected components of a sparse graph
    
        .. versionadded:: 0.11.0
    
        Parameters
        ----------
        csgraph : array_like or sparse matrix
            The N x N matrix representing the compressed sparse graph.  The input
            csgraph will be converted to csr format for the calculation.
        directed : bool, optional
            If True (default), then operate on a directed graph: only
            move from point i to point j along paths csgraph[i, j].
            If False, then find the shortest path on an undirected graph: the
            algorithm can progress from point i to j along csgraph[i, j] or
            csgraph[j, i].
        connection : str, optional
            ['weak'|'strong'].  For directed graphs, the type of connection to
            use.  Nodes i and j are strongly connected if a path exists both
            from i to j and from j to i. A directed graph is weakly connected
            if replacing all of its directed edges with undirected edges produces
            a connected (undirected) graph. If directed == False, this keyword
            is not referenced.
        return_labels : bool, optional
            If True (default), then return the labels for each of the connected
            components.
    
        Returns
        -------
        n_components: int
            The number of connected components.
        labels: ndarray
            The length-N array of labels of the connected components.
    
        References
        ----------
        .. [1] D. J. Pearce, "An Improved Algorithm for Finding the Strongly
               Connected Components of a Directed Graph", Technical Report, 2005
    
        Examples
        --------
        >>> from scipy.sparse import csr_matrix
        >>> from scipy.sparse.csgraph import connected_components
    
        >>> graph = [
        ... [0, 1, 1, 0, 0],
        ... [0, 0, 1, 0, 0],
        ... [0, 0, 0, 0, 0],
        ... [0, 0, 0, 0, 1],
        ... [0, 0, 0, 0, 0]
        ... ]
        >>> graph = csr_matrix(graph)
        >>> print(graph)
          (0, 1)	1
          (0, 2)	1
          (1, 2)	1
          (3, 4)	1
    
        >>> n_components, labels = connected_components(csgraph=graph, directed=False, return_labels=True)
        >>> n_components
        2
        >>> labels
        array([0, 0, 0, 1, 1], dtype=int32)
    """
    pass

def depth_first_order(csgraph, i_start, directed=True, return_predecessors=True): # real signature unknown; restored from __doc__
    """
    depth_first_order(csgraph, i_start, directed=True, return_predecessors=True)
    
        Return a depth-first ordering starting with specified node.
    
        Note that a depth-first order is not unique.  Furthermore, for graphs
        with cycles, the tree generated by a depth-first search is not
        unique either.
    
        .. versionadded:: 0.11.0
    
        Parameters
        ----------
        csgraph : array_like or sparse matrix
            The N x N compressed sparse graph.  The input csgraph will be
            converted to csr format for the calculation.
        i_start : int
            The index of starting node.
        directed : bool, optional
            If True (default), then operate on a directed graph: only
            move from point i to point j along paths csgraph[i, j].
            If False, then find the shortest path on an undirected graph: the
            algorithm can progress from point i to j along csgraph[i, j] or
            csgraph[j, i].
        return_predecessors : bool, optional
            If True (default), then return the predecesor array (see below).
    
        Returns
        -------
        node_array : ndarray, one dimension
            The depth-first list of nodes, starting with specified node.  The
            length of node_array is the number of nodes reachable from the
            specified node.
        predecessors : ndarray, one dimension
            Returned only if return_predecessors is True.
            The length-N list of predecessors of each node in a depth-first
            tree.  If node i is in the tree, then its parent is given by
            predecessors[i]. If node i is not in the tree (and for the parent
            node) then predecessors[i] = -9999.
    
        Examples
        --------
        >>> from scipy.sparse import csr_matrix
        >>> from scipy.sparse.csgraph import depth_first_order
    
        >>> graph = [
        ... [0, 1, 2, 0],
        ... [0, 0, 0, 1],
        ... [2, 0, 0, 3],
        ... [0, 0, 0, 0]
        ... ]
        >>> graph = csr_matrix(graph)
        >>> print(graph)
          (0, 1)	1
          (0, 2)	2
          (1, 3)	1
          (2, 0)	2
          (2, 3)	3
    
        >>> depth_first_order(graph,0)
        (array([0, 1, 3, 2], dtype=int32), array([-9999,     0,     0,     1], dtype=int32))
    """
    pass

def depth_first_tree(csgraph, i_start, directed=True): # real signature unknown; restored from __doc__
    """
    depth_first_tree(csgraph, i_start, directed=True)
    
        Return a tree generated by a depth-first search.
    
        Note that a tree generated by a depth-first search is not unique:
        it depends on the order that the children of each node are searched.
    
        .. versionadded:: 0.11.0
    
        Parameters
        ----------
        csgraph : array_like or sparse matrix
            The N x N matrix representing the compressed sparse graph.  The input
            csgraph will be converted to csr format for the calculation.
        i_start : int
            The index of starting node.
        directed : bool, optional
            If True (default), then operate on a directed graph: only
            move from point i to point j along paths csgraph[i, j].
            If False, then find the shortest path on an undirected graph: the
            algorithm can progress from point i to j along csgraph[i, j] or
            csgraph[j, i].
    
        Returns
        -------
        cstree : csr matrix
            The N x N directed compressed-sparse representation of the depth-
            first tree drawn from csgraph, starting at the specified node.
    
        Examples
        --------
        The following example shows the computation of a depth-first tree
        over a simple four-component graph, starting at node 0::
    
             input graph           depth first tree from (0)
    
                 (0)                         (0)
                /   \                           \
               3     8                           8
              /       \                           \
            (3)---5---(1)               (3)       (1)
              \       /                   \       /
               6     2                     6     2
                \   /                       \   /
                 (2)                         (2)
    
        In compressed sparse representation, the solution looks like this:
    
        >>> from scipy.sparse import csr_matrix
        >>> from scipy.sparse.csgraph import depth_first_tree
        >>> X = csr_matrix([[0, 8, 0, 3],
        ...                 [0, 0, 2, 5],
        ...                 [0, 0, 0, 6],
        ...                 [0, 0, 0, 0]])
        >>> Tcsr = depth_first_tree(X, 0, directed=False)
        >>> Tcsr.toarray().astype(int)
        array([[0, 8, 0, 0],
               [0, 0, 2, 0],
               [0, 0, 0, 6],
               [0, 0, 0, 0]])
    
        Note that the resulting graph is a Directed Acyclic Graph which spans
        the graph.  Unlike a breadth-first tree, a depth-first tree of a given
        graph is not unique if the graph contains cycles.  If the above solution
        had begun with the edge connecting nodes 0 and 3, the result would have
        been different.
    """
    pass

def validate_graph(csgraph, directed, dtype="<class 'numpy.float64'>", csr_output=True, dense_output=True, copy_if_dense=False, copy_if_sparse=False, null_value_in=0, null_value_out=inf, infinity_null=True, nan_null=True): # reliably restored by inspect
    """ Routine for validation and conversion of csgraph inputs """
    pass

# classes

class DTYPE(__numpy.floating, float):
    """
    Double-precision floating-point number type, compatible with Python `float`
        and C ``double``.
    
        :Character code: ``'d'``
        :Canonical name: `numpy.double`
        :Alias: `numpy.float_`
        :Alias on this platform (Linux aarch64): `numpy.float64`: 64-bit precision floating-point number type: sign bit, 11 bits exponent, 52 bits mantissa.
    """
    def as_integer_ratio(self): # real signature unknown; restored from __doc__
        """
        double.as_integer_ratio() -> (int, int)
        
                Return a pair of integers, whose ratio is exactly equal to the original
                floating point number, and with a positive denominator.
                Raise `OverflowError` on infinities and a `ValueError` on NaNs.
        
                >>> np.double(10.0).as_integer_ratio()
                (10, 1)
                >>> np.double(0.0).as_integer_ratio()
                (0, 1)
                >>> np.double(-.25).as_integer_ratio()
                (-1, 4)
        """
        pass

    def is_integer(self): # real signature unknown; restored from __doc__
        """
        double.is_integer() -> bool
        
                Return ``True`` if the floating point number is finite with integral
                value, and ``False`` otherwise.
        
                .. versionadded:: 1.22
        
                Examples
                --------
                >>> np.double(-2.0).is_integer()
                True
                >>> np.double(3.2).is_integer()
                False
        """
        return False

    def __abs__(self, *args, **kwargs): # real signature unknown
        """ abs(self) """
        pass

    def __add__(self, *args, **kwargs): # real signature unknown
        """ Return self+value. """
        pass

    def __bool__(self, *args, **kwargs): # real signature unknown
        """ self != 0 """
        pass

    @classmethod
    def __class_getitem__(cls, *args, **kwargs): # real signature unknown
        pass

    def __divmod__(self, *args, **kwargs): # real signature unknown
        """ Return divmod(self, value). """
        pass

    def __eq__(self, *args, **kwargs): # real signature unknown
        """ Return self==value. """
        pass

    def __float__(self, *args, **kwargs): # real signature unknown
        """ float(self) """
        pass

    def __floordiv__(self, *args, **kwargs): # real signature unknown
        """ Return self//value. """
        pass

    def __ge__(self, *args, **kwargs): # real signature unknown
        """ Return self>=value. """
        pass

    def __gt__(self, *args, **kwargs): # real signature unknown
        """ Return self>value. """
        pass

    def __hash__(self, *args, **kwargs): # real signature unknown
        """ Return hash(self). """
        pass

    def __init__(self, *args, **kwargs): # real signature unknown
        pass

    def __int__(self, *args, **kwargs): # real signature unknown
        """ int(self) """
        pass

    def __le__(self, *args, **kwargs): # real signature unknown
        """ Return self<=value. """
        pass

    def __lt__(self, *args, **kwargs): # real signature unknown
        """ Return self<value. """
        pass

    def __mod__(self, *args, **kwargs): # real signature unknown
        """ Return self%value. """
        pass

    def __mul__(self, *args, **kwargs): # real signature unknown
        """ Return self*value. """
        pass

    def __neg__(self, *args, **kwargs): # real signature unknown
        """ -self """
        pass

    @staticmethod # known case of __new__
    def __new__(*args, **kwargs): # real signature unknown
        """ Create and return a new object.  See help(type) for accurate signature. """
        pass

    def __ne__(self, *args, **kwargs): # real signature unknown
        """ Return self!=value. """
        pass

    def __pos__(self, *args, **kwargs): # real signature unknown
        """ +self """
        pass

    def __pow__(self, *args, **kwargs): # real signature unknown
        """ Return pow(self, value, mod). """
        pass

    def __radd__(self, *args, **kwargs): # real signature unknown
        """ Return value+self. """
        pass

    def __rdivmod__(self, *args, **kwargs): # real signature unknown
        """ Return divmod(value, self). """
        pass

    def __repr__(self, *args, **kwargs): # real signature unknown
        """ Return repr(self). """
        pass

    def __rfloordiv__(self, *args, **kwargs): # real signature unknown
        """ Return value//self. """
        pass

    def __rmod__(self, *args, **kwargs): # real signature unknown
        """ Return value%self. """
        pass

    def __rmul__(self, *args, **kwargs): # real signature unknown
        """ Return value*self. """
        pass

    def __rpow__(self, *args, **kwargs): # real signature unknown
        """ Return pow(value, self, mod). """
        pass

    def __rsub__(self, *args, **kwargs): # real signature unknown
        """ Return value-self. """
        pass

    def __rtruediv__(self, *args, **kwargs): # real signature unknown
        """ Return value/self. """
        pass

    def __str__(self, *args, **kwargs): # real signature unknown
        """ Return str(self). """
        pass

    def __sub__(self, *args, **kwargs): # real signature unknown
        """ Return self-value. """
        pass

    def __truediv__(self, *args, **kwargs): # real signature unknown
        """ Return self/value. """
        pass


class ITYPE(__numpy.signedinteger):
    """
    Signed integer type, compatible with C ``int``.
    
        :Character code: ``'i'``
        :Canonical name: `numpy.intc`
        :Alias on this platform (Linux aarch64): `numpy.int32`: 32-bit signed integer (``-2_147_483_648`` to ``2_147_483_647``).
    """
    def bit_count(self): # real signature unknown; restored from __doc__
        """
        int32.bit_count() -> int
        
                Computes the number of 1-bits in the absolute value of the input.
                Analogous to the builtin `int.bit_count` or ``popcount`` in C++.
        
                Examples
                --------
                >>> np.int32(127).bit_count()
                7
                >>> np.int32(-127).bit_count()
                7
        """
        return 0

    def __abs__(self, *args, **kwargs): # real signature unknown
        """ abs(self) """
        pass

    def __add__(self, *args, **kwargs): # real signature unknown
        """ Return self+value. """
        pass

    def __and__(self, *args, **kwargs): # real signature unknown
        """ Return self&value. """
        pass

    def __bool__(self, *args, **kwargs): # real signature unknown
        """ self != 0 """
        pass

    @classmethod
    def __class_getitem__(cls, *args, **kwargs): # real signature unknown
        pass

    def __divmod__(self, *args, **kwargs): # real signature unknown
        """ Return divmod(self, value). """
        pass

    def __eq__(self, *args, **kwargs): # real signature unknown
        """ Return self==value. """
        pass

    def __float__(self, *args, **kwargs): # real signature unknown
        """ float(self) """
        pass

    def __floordiv__(self, *args, **kwargs): # real signature unknown
        """ Return self//value. """
        pass

    def __ge__(self, *args, **kwargs): # real signature unknown
        """ Return self>=value. """
        pass

    def __gt__(self, *args, **kwargs): # real signature unknown
        """ Return self>value. """
        pass

    def __hash__(self, *args, **kwargs): # real signature unknown
        """ Return hash(self). """
        pass

    def __index__(self, *args, **kwargs): # real signature unknown
        """ Return self converted to an integer, if self is suitable for use as an index into a list. """
        pass

    def __init__(self, *args, **kwargs): # real signature unknown
        pass

    def __int__(self, *args, **kwargs): # real signature unknown
        """ int(self) """
        pass

    def __invert__(self, *args, **kwargs): # real signature unknown
        """ ~self """
        pass

    def __le__(self, *args, **kwargs): # real signature unknown
        """ Return self<=value. """
        pass

    def __lshift__(self, *args, **kwargs): # real signature unknown
        """ Return self<<value. """
        pass

    def __lt__(self, *args, **kwargs): # real signature unknown
        """ Return self<value. """
        pass

    def __mod__(self, *args, **kwargs): # real signature unknown
        """ Return self%value. """
        pass

    def __mul__(self, *args, **kwargs): # real signature unknown
        """ Return self*value. """
        pass

    def __neg__(self, *args, **kwargs): # real signature unknown
        """ -self """
        pass

    @staticmethod # known case of __new__
    def __new__(*args, **kwargs): # real signature unknown
        """ Create and return a new object.  See help(type) for accurate signature. """
        pass

    def __ne__(self, *args, **kwargs): # real signature unknown
        """ Return self!=value. """
        pass

    def __or__(self, *args, **kwargs): # real signature unknown
        """ Return self|value. """
        pass

    def __pos__(self, *args, **kwargs): # real signature unknown
        """ +self """
        pass

    def __pow__(self, *args, **kwargs): # real signature unknown
        """ Return pow(self, value, mod). """
        pass

    def __radd__(self, *args, **kwargs): # real signature unknown
        """ Return value+self. """
        pass

    def __rand__(self, *args, **kwargs): # real signature unknown
        """ Return value&self. """
        pass

    def __rdivmod__(self, *args, **kwargs): # real signature unknown
        """ Return divmod(value, self). """
        pass

    def __repr__(self, *args, **kwargs): # real signature unknown
        """ Return repr(self). """
        pass

    def __rfloordiv__(self, *args, **kwargs): # real signature unknown
        """ Return value//self. """
        pass

    def __rlshift__(self, *args, **kwargs): # real signature unknown
        """ Return value<<self. """
        pass

    def __rmod__(self, *args, **kwargs): # real signature unknown
        """ Return value%self. """
        pass

    def __rmul__(self, *args, **kwargs): # real signature unknown
        """ Return value*self. """
        pass

    def __ror__(self, *args, **kwargs): # real signature unknown
        """ Return value|self. """
        pass

    def __rpow__(self, *args, **kwargs): # real signature unknown
        """ Return pow(value, self, mod). """
        pass

    def __rrshift__(self, *args, **kwargs): # real signature unknown
        """ Return value>>self. """
        pass

    def __rshift__(self, *args, **kwargs): # real signature unknown
        """ Return self>>value. """
        pass

    def __rsub__(self, *args, **kwargs): # real signature unknown
        """ Return value-self. """
        pass

    def __rtruediv__(self, *args, **kwargs): # real signature unknown
        """ Return value/self. """
        pass

    def __rxor__(self, *args, **kwargs): # real signature unknown
        """ Return value^self. """
        pass

    def __str__(self, *args, **kwargs): # real signature unknown
        """ Return str(self). """
        pass

    def __sub__(self, *args, **kwargs): # real signature unknown
        """ Return self-value. """
        pass

    def __truediv__(self, *args, **kwargs): # real signature unknown
        """ Return self/value. """
        pass

    def __xor__(self, *args, **kwargs): # real signature unknown
        """ Return self^value. """
        pass


# variables with complex values

__loader__ = None # (!) real value is '<_frozen_importlib_external.ExtensionFileLoader object at 0xffff932b05b0>'

__spec__ = None # (!) real value is "ModuleSpec(name='scipy.sparse.csgraph._traversal', loader=<_frozen_importlib_external.ExtensionFileLoader object at 0xffff932b05b0>, origin='/.venv/lib/python3.8/site-packages/scipy/sparse/csgraph/_traversal.cpython-38-aarch64-linux-gnu.so')"

__test__ = {
    'breadth_first_order (line 266)': '\n    breadth_first_order(csgraph, i_start, directed=True, return_predecessors=True)\n\n    Return a breadth-first ordering starting with specified node.\n\n    Note that a breadth-first order is not unique, but the tree which it\n    generates is unique.\n\n    .. versionadded:: 0.11.0\n\n    Parameters\n    ----------\n    csgraph : array_like or sparse matrix\n        The N x N compressed sparse graph.  The input csgraph will be\n        converted to csr format for the calculation.\n    i_start : int\n        The index of starting node.\n    directed : bool, optional\n        If True (default), then operate on a directed graph: only\n        move from point i to point j along paths csgraph[i, j].\n        If False, then find the shortest path on an undirected graph: the\n        algorithm can progress from point i to j along csgraph[i, j] or\n        csgraph[j, i].\n    return_predecessors : bool, optional\n        If True (default), then return the predecesor array (see below).\n\n    Returns\n    -------\n    node_array : ndarray, one dimension\n        The breadth-first list of nodes, starting with specified node.  The\n        length of node_array is the number of nodes reachable from the\n        specified node.\n    predecessors : ndarray, one dimension\n        Returned only if return_predecessors is True.\n        The length-N list of predecessors of each node in a breadth-first\n        tree.  If node i is in the tree, then its parent is given by\n        predecessors[i]. If node i is not in the tree (and for the parent\n        node) then predecessors[i] = -9999.\n\n    Examples\n    --------\n    >>> from scipy.sparse import csr_matrix\n    >>> from scipy.sparse.csgraph import breadth_first_order\n\n    >>> graph = [\n    ... [0, 1, 2, 0],\n    ... [0, 0, 0, 1],\n    ... [2, 0, 0, 3],\n    ... [0, 0, 0, 0]\n    ... ]\n    >>> graph = csr_matrix(graph)\n    >>> print(graph)\n      (0, 1)    1\n      (0, 2)    2\n      (1, 3)    1\n      (2, 0)    2\n      (2, 3)    3\n\n    >>> breadth_first_order(graph,0)\n    (array([0, 1, 2, 3], dtype=int32), array([-9999,     0,     0,     1], dtype=int32))\n\n    ',
    'breadth_first_tree (line 122)': '\n    breadth_first_tree(csgraph, i_start, directed=True)\n\n    Return the tree generated by a breadth-first search\n\n    Note that a breadth-first tree from a specified node is unique.\n\n    .. versionadded:: 0.11.0\n\n    Parameters\n    ----------\n    csgraph : array_like or sparse matrix\n        The N x N matrix representing the compressed sparse graph.  The input\n        csgraph will be converted to csr format for the calculation.\n    i_start : int\n        The index of starting node.\n    directed : bool, optional\n        If True (default), then operate on a directed graph: only\n        move from point i to point j along paths csgraph[i, j].\n        If False, then find the shortest path on an undirected graph: the\n        algorithm can progress from point i to j along csgraph[i, j] or\n        csgraph[j, i].\n\n    Returns\n    -------\n    cstree : csr matrix\n        The N x N directed compressed-sparse representation of the breadth-\n        first tree drawn from csgraph, starting at the specified node.\n\n    Examples\n    --------\n    The following example shows the computation of a depth-first tree\n    over a simple four-component graph, starting at node 0::\n\n         input graph          breadth first tree from (0)\n\n             (0)                         (0)\n            /   \\                       /   \\\n           3     8                     3     8\n          /       \\                   /       \\\n        (3)---5---(1)               (3)       (1)\n          \\       /                           /\n           6     2                           2\n            \\   /                           /\n             (2)                         (2)\n\n    In compressed sparse representation, the solution looks like this:\n\n    >>> from scipy.sparse import csr_matrix\n    >>> from scipy.sparse.csgraph import breadth_first_tree\n    >>> X = csr_matrix([[0, 8, 0, 3],\n    ...                 [0, 0, 2, 5],\n    ...                 [0, 0, 0, 6],\n    ...                 [0, 0, 0, 0]])\n    >>> Tcsr = breadth_first_tree(X, 0, directed=False)\n    >>> Tcsr.toarray().astype(int)\n    array([[0, 8, 0, 3],\n           [0, 0, 2, 0],\n           [0, 0, 0, 0],\n           [0, 0, 0, 0]])\n\n    Note that the resulting graph is a Directed Acyclic Graph which spans\n    the graph.  A breadth-first tree from a given node is unique.\n    ',
    'connected_components (line 20)': '\n    connected_components(csgraph, directed=True, connection=\'weak\',\n                         return_labels=True)\n\n    Analyze the connected components of a sparse graph\n\n    .. versionadded:: 0.11.0\n\n    Parameters\n    ----------\n    csgraph : array_like or sparse matrix\n        The N x N matrix representing the compressed sparse graph.  The input\n        csgraph will be converted to csr format for the calculation.\n    directed : bool, optional\n        If True (default), then operate on a directed graph: only\n        move from point i to point j along paths csgraph[i, j].\n        If False, then find the shortest path on an undirected graph: the\n        algorithm can progress from point i to j along csgraph[i, j] or\n        csgraph[j, i].\n    connection : str, optional\n        [\'weak\'|\'strong\'].  For directed graphs, the type of connection to\n        use.  Nodes i and j are strongly connected if a path exists both\n        from i to j and from j to i. A directed graph is weakly connected\n        if replacing all of its directed edges with undirected edges produces\n        a connected (undirected) graph. If directed == False, this keyword\n        is not referenced.\n    return_labels : bool, optional\n        If True (default), then return the labels for each of the connected\n        components.\n\n    Returns\n    -------\n    n_components: int\n        The number of connected components.\n    labels: ndarray\n        The length-N array of labels of the connected components.\n\n    References\n    ----------\n    .. [1] D. J. Pearce, "An Improved Algorithm for Finding the Strongly\n           Connected Components of a Directed Graph", Technical Report, 2005\n\n    Examples\n    --------\n    >>> from scipy.sparse import csr_matrix\n    >>> from scipy.sparse.csgraph import connected_components\n\n    >>> graph = [\n    ... [0, 1, 1, 0, 0],\n    ... [0, 0, 1, 0, 0],\n    ... [0, 0, 0, 0, 0],\n    ... [0, 0, 0, 0, 1],\n    ... [0, 0, 0, 0, 0]\n    ... ]\n    >>> graph = csr_matrix(graph)\n    >>> print(graph)\n      (0, 1)\t1\n      (0, 2)\t1\n      (1, 2)\t1\n      (3, 4)\t1\n\n    >>> n_components, labels = connected_components(csgraph=graph, directed=False, return_labels=True)\n    >>> n_components\n    2\n    >>> labels\n    array([0, 0, 0, 1, 1], dtype=int32)\n\n    ',
    'depth_first_order (line 446)': '\n    depth_first_order(csgraph, i_start, directed=True, return_predecessors=True)\n\n    Return a depth-first ordering starting with specified node.\n\n    Note that a depth-first order is not unique.  Furthermore, for graphs\n    with cycles, the tree generated by a depth-first search is not\n    unique either.\n\n    .. versionadded:: 0.11.0\n\n    Parameters\n    ----------\n    csgraph : array_like or sparse matrix\n        The N x N compressed sparse graph.  The input csgraph will be\n        converted to csr format for the calculation.\n    i_start : int\n        The index of starting node.\n    directed : bool, optional\n        If True (default), then operate on a directed graph: only\n        move from point i to point j along paths csgraph[i, j].\n        If False, then find the shortest path on an undirected graph: the\n        algorithm can progress from point i to j along csgraph[i, j] or\n        csgraph[j, i].\n    return_predecessors : bool, optional\n        If True (default), then return the predecesor array (see below).\n\n    Returns\n    -------\n    node_array : ndarray, one dimension\n        The depth-first list of nodes, starting with specified node.  The\n        length of node_array is the number of nodes reachable from the\n        specified node.\n    predecessors : ndarray, one dimension\n        Returned only if return_predecessors is True.\n        The length-N list of predecessors of each node in a depth-first\n        tree.  If node i is in the tree, then its parent is given by\n        predecessors[i]. If node i is not in the tree (and for the parent\n        node) then predecessors[i] = -9999.\n\n    Examples\n    --------\n    >>> from scipy.sparse import csr_matrix\n    >>> from scipy.sparse.csgraph import depth_first_order\n\n    >>> graph = [\n    ... [0, 1, 2, 0],\n    ... [0, 0, 0, 1],\n    ... [2, 0, 0, 3],\n    ... [0, 0, 0, 0]\n    ... ]\n    >>> graph = csr_matrix(graph)\n    >>> print(graph)\n      (0, 1)\t1\n      (0, 2)\t2\n      (1, 3)\t1\n      (2, 0)\t2\n      (2, 3)\t3\n\n    >>> depth_first_order(graph,0)\n    (array([0, 1, 3, 2], dtype=int32), array([-9999,     0,     0,     1], dtype=int32))\n\n    ',
    'depth_first_tree (line 192)': '\n    depth_first_tree(csgraph, i_start, directed=True)\n\n    Return a tree generated by a depth-first search.\n\n    Note that a tree generated by a depth-first search is not unique:\n    it depends on the order that the children of each node are searched.\n\n    .. versionadded:: 0.11.0\n\n    Parameters\n    ----------\n    csgraph : array_like or sparse matrix\n        The N x N matrix representing the compressed sparse graph.  The input\n        csgraph will be converted to csr format for the calculation.\n    i_start : int\n        The index of starting node.\n    directed : bool, optional\n        If True (default), then operate on a directed graph: only\n        move from point i to point j along paths csgraph[i, j].\n        If False, then find the shortest path on an undirected graph: the\n        algorithm can progress from point i to j along csgraph[i, j] or\n        csgraph[j, i].\n\n    Returns\n    -------\n    cstree : csr matrix\n        The N x N directed compressed-sparse representation of the depth-\n        first tree drawn from csgraph, starting at the specified node.\n\n    Examples\n    --------\n    The following example shows the computation of a depth-first tree\n    over a simple four-component graph, starting at node 0::\n\n         input graph           depth first tree from (0)\n\n             (0)                         (0)\n            /   \\                           \\\n           3     8                           8\n          /       \\                           \\\n        (3)---5---(1)               (3)       (1)\n          \\       /                   \\       /\n           6     2                     6     2\n            \\   /                       \\   /\n             (2)                         (2)\n\n    In compressed sparse representation, the solution looks like this:\n\n    >>> from scipy.sparse import csr_matrix\n    >>> from scipy.sparse.csgraph import depth_first_tree\n    >>> X = csr_matrix([[0, 8, 0, 3],\n    ...                 [0, 0, 2, 5],\n    ...                 [0, 0, 0, 6],\n    ...                 [0, 0, 0, 0]])\n    >>> Tcsr = depth_first_tree(X, 0, directed=False)\n    >>> Tcsr.toarray().astype(int)\n    array([[0, 8, 0, 0],\n           [0, 0, 2, 0],\n           [0, 0, 0, 6],\n           [0, 0, 0, 0]])\n\n    Note that the resulting graph is a Directed Acyclic Graph which spans\n    the graph.  Unlike a breadth-first tree, a depth-first tree of a given\n    graph is not unique if the graph contains cycles.  If the above solution\n    had begun with the edge connecting nodes 0 and 3, the result would have\n    been different.\n    ',
}

